# 排序



## 排序

- **排序**（Sort），就是重新排列表中的元素，使表中的元素满足按**关键字有序**的过程。

- 算法的稳定性：稳定的算法是关键字相同的元素在排序之后相对位置不变。反之是不稳定的。

- 内部排序：数据都在内存中。（关注如何使算法时、空复杂度更低）

  外部排序：数据太多，无法全部放入内存。（还要关注如何使读/写磁盘次数更少）



## 插入排序

- 算法思想：每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。

- 代码实现：

  ~~~c
  //直接插入排序
  void InserSort(int A[],int n){
  	int i,j,temp;
  	for(i=1;i<n;i++)							//将各元素插入已排好序的序列中
  		if(A[i]<A[i-1]){						//若A[i]关键字小于前驱
  			temp=A[i];							//用temp暂存A[i]
  			for(j=i-1;j>0 && A[j]>temp;--j)		//检查所有前面已排好序的元素
  				A[j+1]=A[j];					//所有大于temp的元素都向后挪位
  			A[j+1]=temp;						//复制到插入位置
  		}
  }
  ~~~

  若带哨兵，则不用每轮循环都判断j>=0。

- 空间复杂度：O(1)。

  时间复杂度：主要来自对比关键字、移动元素。若有n个元素，则需要n-1趟处理。

  ​	最好情况：共n-1趟处理，每一趟只需要对比关键字1次，不用移动元素。（原本就有序）

  ​	最好时间复杂度——O(n)。

  ​	最坏情况：原本为逆序。

  ​	**最坏时间复杂度——O(n²)**。

- 算法稳定性：稳定。

- 优化——折半插入排序

  ​	思路：先用折半查找找到应该插入的位置，再移动元素。

  ​	当low>high时折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]复制到low所指位置。

  ​	当A[mid]==A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置。

  比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是O(n²)。

- 对链表进行插入排序：移动元素的次数变少了，但是关键字对比的次数依然是O(n²)数量级，整体来看时间复杂度依然是O(n²)。



## 希尔排序

- 希尔排序：先将待排序表分割成形如L[i,i+d,i+2d,...,i+kd]的“特殊”子表，对各个子表分别进行直接插入排序。缩小**增量d**，重复上述操作，直到 d=1为止。（先追求表中元素部分有序，再逐渐逼近全局有序。）

- 例：                            49，38，65，97，76，13，27，<u>49</u>

  第一趟：d₁=n/2=4	49，13，27，<u>49</u>，76，38，65，97

  第二趟：d₂=d₁/2=2	27，13，49，38，65，<u>49</u>，76，97

  第三趟：d₃=d₂/2=1	13，27，38，49，<u>49</u>，65，76，97

  （建议：每次将增量缩小一半。）

- 代码实现：

  ~~~c
  //希尔排序
  void ShellSort(int A[],int n){
  	int d,i,j;
  	//A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置
  	for(d=n/2;d>=1;d=d/2)		//步长变化
  		for(i=d+1;i<=n;++i)
  			if(A[i]<A[i-d]){				//需将A[i]插入有序增量子表
  				A[0]=A[i];					//暂存在A[0]
  				for(j=i-d;j>0 && A[0]<A[j];j-=d)
  					A[j+d]=A[j];			//记录后移，查找插入的位置
  				A[j+d]=A[0];				//插入
  			}
  }
  ~~~

- 空间复杂度：O(1)。

  时间复杂度：和增量序列d₁，d₂，d₃...的选择有关，目前**无法用数学手段证明确切的时间复杂度**。

  ​	最坏时间复杂度：O(n²)。（直接插入排序）

- 算法稳定性：不稳定。

- 适用性：仅适用于顺序表，不适用于链表。



## 冒泡排序

- 基于“交换”的排序：根据序列中两个元素关键字的比较结果来对换两个记录在序列中的位置。

- 冒泡排序：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]，同时算法稳定），则交换它们，直到序列比较完。称这样的过程为“一趟”冒泡排序。

  第一趟结束：会使关键字最小的一个元素“冒”到最前面。

  第二趟结束：会使关键字最小的两个元素“冒”到最前面。

  ....

  **若某一趟排序没有发生“交换”，说明此时已经整体有序，可提前结束。**

- 算法实现：

  ~~~c
  //冒泡排序
  void BubbleSort(int A[],int n){
  	for(int i=0;i<n-1;i++){
  		bool flag=false;			//表示本趟冒泡是否发生交换的标志
  		for(int j=n-1;j>i;j--)		//一趟冒泡过程
  			if(A[i-1]>A[i]){		//若为逆序
  				swap(A[j-1],A[j]);	//交换
  				flag=true;
  			}
  		if(flag==false)
  			return;					//本趟遍历后没有发生交换，说明表已经有序
  	}
  }
  ~~~

- 空间复杂度：O(1)。

  时间复杂度：最好情况：有序，比较次数=n-1；交换次数=0。

  ​					   最好时间复杂度=O(1)。

  ​					   最坏情况：逆序，比较次数=(n-1)+(n-2)+...+1=n(n-1)/2=交换次数。

  ​					   最坏时间复杂度=O(n²)。

- 算法稳定性：稳定。

- 同样适用于链表。



## 快速排序

- 同冒泡一样是基于“交换”的排序：根据序列中两个元素关键字的比较结果来对换两个记录在序列中的位置。

- 算法思想：在待排序表L[1...n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1...k-1]和L[k+1...n]，使得L[1...k-1]中的所有元素小于pivot，L[k+1...n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。

- 用第一个元素把待排序序列“划分”为两个部分。左边更小，右边更大。（一次“划分”≠一趟排序）

- 算法实现：

  ~~~c
  //用第一个元素将待排序序列划分成左右两部分
  int Partition(int A[],int low,int hight){
  	int pivot=A[low];		//第一个元素作为枢轴
  	while(low<high){		//用low、high搜索枢轴的最终位置
  		while(low<high && A[high]>=pivot)	--high;
  		A[low]=A[high];		//比枢轴小的元素移动到左端
  		while(low<high && A[low]<=pivot)	++low;
  		A[high]=A[low];		//比枢轴大的元素移动到右端
  	}
  	A[low]=pivot;			//枢轴元素存放到最终位置
  	return low;				//返回存放枢轴的最终位置
  }
  
  //快速排序
  void QuickSort(int A[],int low,int high){
  	if(low<high){						//递归跳出的条件
  		int pivotpos=Partition(A,low,high);	//划分
  		QuickSort(A,low,pivotpos-1);		//划分左子表
  		QuickSort(A,pivotpos+1,high);		//划分右子表
  	}
  }
  ~~~

- 时间复杂度：O(n*递归层数)。

  ​	最好时间复杂度=O(n㏒₂n)。

  ​	最坏时间复杂度=O(n²)。

  ​	平均时间复杂度=O(n㏒₂n)。

  空间复杂度：O(递归层数)。

  ​	最好空间复杂度=O(㏒₂n)。

  ​	最坏空间复杂度=O(n)。

  把n个元素组织成二叉树，二叉树的层数就是递归调用的层数。

- 若每一次选中的“枢轴”将待排序序列划**分为均匀的两个部分，则递归深度最小，算法效率最高**。

  若每一次选中的“枢轴”将待排序序列划**分为很不均匀的两个部分，则递归深度增加，算法效率变低**。

  若初始序列有序或逆序，则快速排序的性能最差。（因为每次选择的都是最靠边的元素）

- 快速排序算法优化思路：尽量选择可以把数据中分的枢轴元素。

  ①选头、中、尾三个位置的元素，取中间值作为枢轴元素。

  ②随机选一个元素作为枢轴元素。

- 快速排序是所有内部排序算法中平均性能最优的排序算法。

- 算法稳定性：不稳定。



## 简单选择排序

- 选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。

- 算法实现：

  ~~~c
  //简单选择排序
  void SelectSort(int A[],int n){
  	for(int i=0;i<n-1;i++){					//一共进行n-1遍
  		int min=i;							//记录最小元素位置
  		for(int j=i+1;j<n;j++)				//在A[i...n-1]中选择最小的元素
  			if(A[j]<A[min])	min=j;			//更新最小元素位置
  		if(min != i)	swap(A[i],A[min]);	//封装的swap()函数共移动元素3次（交换这两个数的位置）
  	}
  }
  ~~~

- 空间复杂度：O(1)。

  时间复杂度：O(n²)。无论有序、逆序还是乱序，一定需要n-1趟处理。总共需要对比关键字(n-1)+(n-2)+...+1=n(n-1)/2次，元素交换次数<n-1。

- 稳定性：不稳定。

- 实用性：既适用于顺序表，也可用于链表。



## 堆排序

- 选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。

- 若n个关键字序列L[1...n]满足下面某一条性质，则称为堆（Heap）：

  ①若满足：L(i)≧L(2i)且L(i)≧L(2i+1)	(1≦i≦n/2)——**大根堆**（大顶堆）。

  ②若满足：L(i)≦L(2i)且L(i)≦L(2i+1)	(1≦i≦n/2)——**小根堆**（小顶堆）。

- **大根堆：完全二叉树中，根≧左、右；小根堆：完全二叉树中，根≦左、右。**

- 思路：把所有**非终端结点**（**编号i≦n/2**）都检查一遍，是否满足大根堆的要求（**根≧左、右**），如果不满足，则进行调整（将**当前节点与更大的一个孩子互换**）。（i的左孩子是2i；i的右孩子是2i+1；i的父节点是i/2）若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）。

- 建立大根堆算法实现：

  ~~~c
  //建立大堆根
  void BuildMaxHeap(int A[],int len){
  	for(int i=len/2;i>0;i--)			//从后往前调整所有非终端结点
  		HeadAdjust(A,i,len);
  }
  
  //将以k为根的子树调整为大堆根
  void HeadAdjust(int A[],int k,int len){
  	A[0]=A[k];							//A[0]暂存子树的根节点
  	for(int i=2*k;i<=len;i*=2){			//沿key较大的子节点向下筛选
  		if(i<len && A[i]<A[i+1])
  			i++;						//取key较大的子结点的下标
  		if(A[0]>=A[i])	break;			//筛选结果
  		else{
  			A[k]=A[i];					//将A[i]调整到双亲结点上
  			k=i;						//修改k值，以便继续向下筛选
  		}
  	}
  	A[k]=A[0];							//被筛选结点的值放入最终位置
  }
  ~~~

- 基于大根堆进行堆排序：每一趟将堆顶元素加入有序子序列（与待排序序列中的最后一个元素交换），并将待排序元素序列再次调整为大根堆（小元素不断“下坠”）。

  （注意：基于“大根堆”的堆排序得到“递增序列”，基于“小根堆”的堆排序得到“递减序列”。）

- 基于大根堆进行排序算法实现：

  ~~~c
  //堆排序的完整逻辑
  void HeadSort(int A[],int len){
  	BuildMaxHeap(A,len);			//初始建堆
  	for(int i=len;i>1;i--){			//n-1趟的交换和建堆过程
  		swap(A[i],A[1]);			//堆顶元素和堆底元素交换
  		HeadAdjust(A,1,i-1);		//把剩余的待排序元素整理成堆
  	}
  }
  ~~~

- 结论：一个结点，每“下坠”一层，最多只需对比关键字2次。若树高为h，某节点在第i层，则将这个节点向下调整最多只需要“下坠”h-i层，关键字对比次数不超过2(h-i)。n个结点的完全二叉树高h=(㏒₂n)+1。

  建堆的过程，关键字对比次数不超过4n，建堆时间复杂度=O(n)。

  根节点最多“下坠”h-1层，而每“下坠”一层，最多只需对比关键字2次，因此每一趟排序复杂度不超过O(h)=O(㏒₂n)。共n-1趟，总的时间复杂度=O(h=(n㏒₂n))。

- 堆排序的时间复杂度=O(n)+O(n㏒₂n)=O(n㏒₂n)。

  堆排序的空间复杂度=O(1)。

- 稳定性：不稳定。

- 堆中插入元素：对于**小根堆**，**新元素**放到**表尾**，与父节点对比，若新元素比父节点**更小**，则将二者互换。新元素就这样一路“**上升**”，直到无法继续上升为止。

- 堆中删除元素：对于**小根堆**，被删除的元素**用堆底元素替代**，然后让该元素不断“**下坠**”，直到无法下坠为止。

- 下方有两个孩子，则“下坠”一层，需对比关键字2次。

  下方只有一个孩子，则“下坠”一层，只需对比关键字1次。



## 归并排序

- 归并：把**两个**或多个已经**有序**的序列**合并**成一个。

- 对比i、j所指元素，选择更小的一个放入k所指位置。（“2路”归并——每选出一个小元素需对比关键字1次）

  对比p1、p2、p3、p4所指元素，选择更小的一个放入k所指位置。（“4路”归并——每选出一个小元素需对比关键字3次）

  m路归并，每选出一个元素需要对比关键字m-1次。

- 代码实现：

  ~~~c
  int *B=(int *)malloc(n*sizeof(int));		//辅助数组B
  
  //A[low...mid]和A[mid+1...high]各自有序，将两个部分归并
  void Merge(int A[],int low,int mid,int high){
  	int i,j,k;
  	for(k=low;k<=high;k++)
  		B[k]=A[k];						//将A中所有元素复制到B中
  	for(i=low,j=mid+1,k=i;i<=mid && j<=high;k++){
  		if(B[i]<=B[j])
  			A[k]=B[i++];				//将较小值复制到A中
  		else
  			A[k]=B[j++];
  	}
  	while(i<=mid)	A[k++]=B[i++];
  	while(j<=high)	A[k++]=B[j++];
  }
  
  void MergeSort(int A[],int low,int high){
      if(low<high){
          int mid=(low+high)/2;		//从中间划分
          MergeSort(A,low,mid);		//对左半部分归并排序
          MergeSort(A,mid+1,high);	//对右半部分归并排序
          Merge(A,low,mid,high);		//归并
      }
  }
  ~~~

- 2路归并的“归并树”——形态上就是一棵倒立的二叉树。二叉树的第h层最多有2^(h-1)个结点，若树高为h，则应满足n≦2^(h-1)即h-1=㏒₂n。

  结论：n个元素进行2路归并排序，归并趟数=㏒₂n。

- 每趟归并时间复杂度为O(n)，则算法时间复杂度为O(n㏒₂n)。

  空间复杂度O(n)，来自于辅助数组B。

- 稳定性：稳定。



## 基数排序

- 要求：得到按关键字“递减”的序列。

- 第一趟“分配”：以“个位”进行“分配”。第一趟“收集”：得到按“个位”递减排序的序列。

  第二趟“分配”：以“十位”进行“分配”。第二趟“收集”：得到按“十位”递减排序的序列。

  第三趟“分配”：以“百位”进行“分配”。第三趟“收集”：得到按“百位”递减排序的序列。

  ...

- 基数排序得到**递减**序列的过程如下：

  1. **初始化**：设置r个空队列，Q(r-1),Q(r-2),Q₀。按照各个**关键字位权重递增的次序**（个、十、百），对d个关键字位分别做“分配”和“收集”。
  2. **分配**：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入Q(x)队尾。
  3. **收集**：把Q(r-1),Q(r-2),Q₀各个队列中的结点依次出队并链接。

- **基数排序不是基于“比较”的排序算法。**

- 需要r个辅助队列，空间复杂度=O(r)。

  一趟分配O(n)，一趟收集O(r)，总共d趟分配、收集，总的时间复杂度=O(d(n+r))（把关键字拆为d个部分，每个部分可能取得r个值）。

- 稳定性：稳定。

- 基数排序擅长解决的问题：

  ①数据元素的关键字可以很方便地拆分为d组，且d较小。

  ②每组关键字的取值范围不大，即r较小。

  ③数据元素个数n较大。



## 外部排序

- 使用“归并排序”的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文本文件进行排序。

- “归并排序”要求各个子序列有序，每次读入两个块的内容，进行内部排序后写回磁盘。

- 生成初始归并段——第一趟归并——第二趟归并——第三趟归并...

- 生成初始归并段的“内存工作区”越大，初始归并段越长。

- 外部排序时间开销=读写外存的时间+内部排序所需时间+内部归并所需时间。

- 重要结论：采用多路归并可以减少归并趟数，从而减少磁盘I/O（读写）次数。

  对r个初始归并段，做k路归并，则归并树可用k叉树表示，若树高为h，则归并趟数=h-1=㏒(k为底，r为对数)。（**k越大，r越小，归并趟数越小，读写磁盘次数越少**）

  推导：k叉树第h层最多有k^(h-1)个结点，则r≦k^(h-1)，(h-1)最小=㏒(k为底，r为对数)。

- 多路归并带来的负面影响：

  ①k路归并时，需要开辟k个输入缓冲区，内存开销增加。

  ②每挑选一个关键字需要对比关键字(k-1)次，内部归并所需时间增加。

- 结论：若能增加初始归并段的长度，则可减少初始归并段数量r。

- 若共N个记录，内存工作区可以容纳L个记录，则初始归并段数量r=N/L。

- **k路平衡归并**：①最多只能有k个段归并为一个；②每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到m/k个新的归并段。（满足这两个条件才能称为平衡）

### 败者树

- 败者树——可视为一棵完全二叉树（多了一个头）。k个叶节点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根节点。
- 根节点记录冠军来自哪个归并段；分支节点记录失败者来自哪个归并段；每个叶子节点对应一个归并段。
- 对于k路归并，第一次构造败者树需要对比关键字k-1次。
- 有了败者树，选出最小元素，只需对比关键字㏒₂k次。
- k路归并的败者树只需要定义一个长度为k的数组即可。
- 败者树解决的问题：使**用多路平衡归并**可减少归并趟数，但是用老土的方法从k个归并段选出一个最小或最大元素需要对比关键字k-1次，构造败者树可以使关键字**对比次数减少到㏒₂k**。
- 败者树可视为一棵完全二叉树（多了一个头）。**k个叶节点分别对应k个归并段中当前参加比较的元素**，**非叶子节点用来记忆左右子树中的“失败者”**，而让胜者往上继续进行比较，一直到根节点。

### 置换-选择排序

- 设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置换-选择算法的步骤如下：
  1. 从FI输入w个记录到工作区WA。
  2. 从WA中选出其中关键字取得最小值的记录，记为MINIMAX记录。
  3. 将MINIMAX记录输出到FO中去。
  4. 若FI不空，则从FI输入下一个记录到WA中。
  5. 从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。
  6. 重复(3)~(5)，直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。
  7. 重复(2)~(6)，直至WA为空。由此得到全部初始归并段。
- 若WA内的关键字都比MINIMAX更小，则该归并段在此截止。
- 使用置换-选择排序，可以让每个初始归并段的长度超越内存工作区大小的限制。

### 最佳归并树

- 归并过程中的磁盘I/O次数=归并树的WPL*2。所以要让磁盘I/O次数最少，就要使归并树WPL最小（哈夫曼树）。

- 对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的“虚设”，再进行k叉哈夫曼树的构造。

- k叉的最佳归并树一定是一棵严格的k叉树，即树种只包含度为k、度为0的结点。

- 设度为k的结点有n(k)个，度为0的结点有n₀个，归并树总结点数=n，则：

  初始归并段数量+虚段数量=n₀

  n=n₀+n(k)

  kn(k)=n-1

  n₀=(k-1)n(k)+1

  n(k)=(n₀-1)/(k-1)	（如果是“严格k叉树”一定能除得尽）

  ①若（初始归并段数量-1）%（k-1）= 0，说明刚好可以构成严格k叉树，此时不需要添加虚段。

  ②若（初始归并段数量-1）%（k-1）= u ≠ 0，则需要补充（k-1）-u个虚段。