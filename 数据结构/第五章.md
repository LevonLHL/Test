

# 第五章 树与二叉树



## 树

- 树由根节点、边、分支节点、叶子节点组成。

- 树是递归定义的数据结构。

- 空树：结点数为0的树。

- 非空树的特性：有且仅有一个根节点。

  ​							没有后继的结点称为“叶子节点”（或终端节点）。

  ​							有后继的节点称为“分支节点”（或非终端节点）。

  ​							除了根节点外，任何一个节点都有且仅有一个前驱。

  ​							每个节点可以有0个或多个后继。

- 属性：结点的层次（深度）——从上往下数

  ​			结点的高度——从下往上数

  ​			树的高度（深度）——总共多少层

  ​			**结点的度**——有几个孩子（分支）（非叶子节点的度>0；叶子节点的度=0）

  ​			**树的度**——各结点的度的最大值

- 有序树：逻辑上看，树中结点的各子树从左至右是有次序的，不能互换。

  无序树：逻辑上看，树中结点的各子树从左至右是无次序的，可以互换。

- **森林**：森林是m（m≧0）棵互不相交的树的集合。

- 常考性质：**结点数=总度数+1**

  ​					**度为m的数、m叉树的区别**

  | 度为m的数                         | m叉树的区别                   |
  | --------------------------------- | ----------------------------- |
  | 任意节点的度≦m（最多m个孩子）     | 任意结点的度≦m（最多m个孩子） |
  | 至少有一个结点的度=m（有m个孩子） | 允许所有结点的度都<m          |
  | 一定是非空树，至少有m+1个结点     | 可以是空树                    |

  ​					**度为m的树和m叉树第i层至多有m^(i-1)个结点（i≥1）**

  ​					**高度为h的m叉树至多有[(m^h)-1]/(m-1)个结点，最少有h个结点**

  ​					**高度为h、度为m的树至少有h+m-1个结点**

  ​					**具有n个结点的m叉树的最小高度为㏒(m为底)((n(m-1)+1)为对数)**



## 二叉树

- **二叉树**是n(n≥0)个结点的有限集合：①或者为空二叉树，即n=0。

  ​															 ②或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别																是一棵二叉树。

- 特点：每个节点至多只有两棵子树；左右子树不能颠倒（二叉树是有序树）。

- 二叉树也是递归定义的数据结构。

- **满二叉树**：一棵高度为h，且含有(2^h)-1个结点的二叉树。特点：

  1. 只有最后一层有叶子节点。
  2. 不存在度为1的结点。
  3. **按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为i/2（如果有的话）。**

- **完全二叉树**：当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。特点：

  1. 只有最后两层可能有叶子节点。
  2. **最多只有一个度为1的结点**。
  3. 同上（3）。
  4. i≤(n/2)为分支节点，i>(n/2)为叶子节点。

- **二叉排序树**：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：

  1. **左子树**上所有结点的关键字均**小于**根节点的关键字。
  2. **右子树**上所有结点的关键字均**大于**根节点的关键字。
  3. 左子树和右子树又各是一棵二叉排序树。

  二叉排序树可以用于元素的排序、搜索。

- **平衡二叉树**：树上任一节点的左子树和右子树的深度之差不超过1。

  平衡二叉树能有更高的搜索效率。

- 常考性质：

  1. 设非空二叉树中度为0、1和2的结点个数分别为n₀、n₁和n₂，则**n₀=n₂+1**。（叶子节点比二分支结点多一个）

     假设树中结点总数为n，则：n=n₀+n₁+n₂=n₁+2n₂+1。（树的结点数=总度数+1）

  2. 二叉树第i层至多有2^(i-1)个结点，m叉树第i层至多有m^(i-1)个结点。

  3. 高度为h的二叉树至多有（2^h）-1个结点（满二叉树），高度为h的m叉树至多有[(m^h)-1]/(m-1)个结点。

  4. 具有n个（n>0）结点的完全二叉树的高度h为㏒₂(n+1）或(㏒₂n)+1。

  5. 对于完全二叉树，可以由结点数n推出度为0、1和2的结点个数n₀、n₁和n₂。

     完全二叉树最多只有一个度为1的结点，即n₁=0或1，且由n₀=n₂+1可以推出n₀+n₂一定是奇数，可得以下结论：

     若完全二叉树有2k个（偶数）结点，则必有n₁=1，n₀=k，n₂=k-1。

     若完全二叉树有2k-1个（奇数）结点，则必有n₁=0，n₀=k，n₂=k-1。

- 存储结构：

  **顺序存储**：定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个节点。（注：①可以让第一个位置空缺，保证数组下标和结点编号一致。②初始化时所有结点标记为空。）

  ​	重要常考基本操作：i的左孩子——2i

  ​									   i的右孩子——2i+1

  ​									   i的父节点——i/2

  ​								   	i所在的层次——㏒₂(n+1）或(㏒₂n)+1

  ​	若判断完全二叉树中共有n个结点，则：（若为非完全二叉树则不适用）

  ​									判断i是否有左孩子——2i≦n

  ​									判断i是否有右孩子——2i+1≦n

  ​									判断i是否是叶子\分支结点——i>n/2

  ​	所以，在二叉树的顺序存储中，**一定要把二叉树的结点编号与完全二叉树对应起来**。

  ​	最坏情况：高度为h且只有h个结点的单支树（所有结点只有右孩子），也至少需要(2^h)-1个存储单元。

  ​	结论：二叉树的顺序存储结构，只适合存储完全二叉树。

  **链式存储**：需要定义数据域和左、右孩子指针。

  ​	**n个结点的二叉链表共有n+1个空链域**（可以用于构造线索二叉树）。

  ​	三叉链表：在上面的定义方式中再加一个父节点指针。（方便找父节点）



## 二叉树的先/中/后序遍历

- 遍历：按照某种次序把所有结点都访问一遍。

- **先序遍历：根左右**（NLR）

  ​	操作过程：1、若二叉树为空，则什么都不做。

  ​						2、若二叉树非空：①访问根节点。②先序遍历左子树。③先序遍历右子树。

  ```c
  void PreOrder(BiTree T){
  	if(T != NULL)
  	visit(T);
  	PreOrder(T->lchild);
  	PreOrder(T->rchild);
  }
  ```

  ​	空间复杂度O(h)。

  ​	从根节点出发，画一条路线：如果左边还有没走的路，优先往左边走走到路的尽头（空节点）就往回走；如果左边没路了，就往右边走，如果左、右都没路了，则往上面走。

  ​	第一次路过时访问节点。（每个节点都会被路过3次）

  **中序遍历：左根右**（LNR）

  ​	操作过程：1、若二叉树为空，则什么都不做。

  ​						2、若二叉树非空：①先序遍历左子树。②访问根节点。③先序遍历右子树。

  ​	（同上）

  ​	第二次路过时访问节点。

  **后序遍历：左右根**（LRN）

  ​	操作过程：1、若二叉树为空，则什么都不做。

  ​						2、若二叉树非空：①先序遍历左子树。②先序遍历右子树。③访问根节点。

  ​	（同上）

  ​	第三次路过时访问节点。

- 先序遍历->前缀表达式

  中序遍历->中缀表达式（需要加界限符）

  后序遍历->后缀表达式

- 求树的深度：

  ```c
  int treeDepth(BiTree T){
  	if(T == NULL){
  		return 0;
  	}
  	else{
  		int l = treeDepth(T->lchild);
  		int r = treeDepth(T->rchild);
  		//树的深度=MAX(左子树深度,右子树深度)+1
  		return l>r ? l+1 : r+1;
  	}
  }
  ```

   

- **层次遍历**：

  ​	算法思想： ①初始化一个辅助**队列**。

  ​						②根节点入队。

  ​						③若队列非空，则队头节点出队，访问该节点，并将其左、右孩子插入队尾（如果有的话）。

  ​						④重复③直至队列为空。

- **由遍历序列构造二叉树**：

  ​	若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树。

  ​	方法：找到树的根节点，并根据**中序序列（必不可少）**划分左右子树，再找到左右子树根节点，一直递归到最后一个节点。

- **线索二叉树**：

  ​	问：如何找到指定结点p在中序遍历序列中的前驱？如何找到p的中序后继？

  ​	答：从根节点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个被访问的结点。当q==p时，pre为前驱；当pre==p时，q为后继。（缺点：找前驱、后继很不方便；遍历操作必须从根开始。）

  **中序线索二叉树**：n个结点的二叉树，有n+1个空链域，可用来记录前驱、后继的信息。（指向前驱、后继的指针被称为“线索”）

  ​								前驱线索（由左孩子指针充当），后继线索（由右孩子指针充当）。

  存储结构：**只需在二叉链表中加入ltag和rtag分别表示左、右线索标识。tag==0，表示指针指向孩子；tag==1，表示指针是“线索”。**

  前序线索二叉树、后序线索二叉树同理。

  中序线索二叉树——线索指向中序前驱、中序后继。

  先序线索二叉树——线索指向先序前驱、先序后继。

  后序线索二叉树——线索指向后序前驱、后序后继。

  手算画出线索二叉树： ①确定线索二叉树的类型——中序、先序、后序。

  ​										②按照对应遍历规则，确定各个结点的访问顺序，并写上编号。

  ​										③将n+1个空链域连上前驱、后继。（没的连NULL）

- **二叉树线索化**：（以中序为例）

  ~~~c
  //全局变量pre，指向当前访问结点的前驱
  ThreadNode *pre=NULL;
  //中序遍历二叉树，一边遍历一边线索化
  void InThread(ThreadTree T){
  	if(T != NULL){
          InThread(T->lchild);			//中序遍历左子树
          visit(T);						//访问根节点
          InThread(T->rchild);			//中序遍历右子树
  	}
  }
  void visit(ThreadNode *q){
  	if(q->lchild==NULL){				//左子树为空，建立前驱线索
  		q->lchild=pre;
  		q->ltag=1;
  	}
  	if(pre != NULL && pre->rchild==NULL){				
  		pre->rchild=q;					//建立前驱结点的后继线索
  		qre->rtag=1;
  	}
  	pre=q;
  }
  ~~~

  初始建成的树，ltage、rtage=0。

  最后还要检查pre的rchild是否为NULL，如果是，则令rtag=1。

- **在线索二叉树中找前驱、后继**：

  ​	**中序线索二叉树找中序后继**：在中序线索二叉树中找到指定结点 *p的中序后继next

  ​													①若p->rtag==1，则next=p->rchild。

  ​													②若p->rtag==0，next等于p的右子树中最左下结点。（左，*根*，<u>右</u>）->（左，*根*，（<u>左</u>，根，右））

  找到以p为根的子树中，第一个被中序遍历的结点：

  ~~~c
  ThreadNode *Firstnode(ThreadNode *p){
  	//循环找到最左下结点（不一定是叶子节点）
  	while(p->ltag==0) p=p->lchild;
  	return p;
  }
  ~~~

  在中序线索二叉树中找到结点p的后继节点：

  ~~~C
  ThreadNode *Nextnode(ThreadNode *p){
  	//右子树中最左下节点
  	if(p->rtag==0) return Firstnode(p->rchild);
  	else return p->rchild;							//rtag==1直接返回后继线索
  }
  ~~~

  对中序线索二叉树进行中序遍历（利用线索实现的非递归算法（空间复杂度O(1））：

  ~~~c
  void Inorder(ThreadNode *T){
  	for(ThreadNode *p = Firstnode(T);p != NULL;p = Nextnode(p))
  		visit(p);
  }
  ~~~

  ​		**中序线索二叉树找中序前驱**：在中序线索二叉树中找到指定结点 *p的中序前驱pre

  ​													①若p->ltag==1，则pre=p->lchild。

  ​													②若p->ltag==0，pre等于p的左子树中最右下结点。（<u>左</u>，*根*，右）->（（左，根，<u>右</u>），*根*，右）

  找到以p为根的子树中，第一个被中序遍历的结点：

  ~~~c
  ThreadNode *Lastnode(ThreadNode *p){
  	//循环找到最右下结点（不一定是叶子节点）
  	while(p->rtag==0) p=p->rchild;
  	return p;
  }
  ~~~

  在中序线索二叉树中找到结点p的前驱节点：

  ~~~C
  ThreadNode *Prenode(ThreadNode *p){
  	//左子树中最右下节点
  	if(p->ltag==0) return Lastnode(p->lchild);
  	else return p->lchild;							//ltag==1直接返回后继线索
  }
  ~~~

  对中序线索二叉树进行**逆向**中序遍历（利用线索实现的非递归算法（空间复杂度O(1））：

  ~~~c
  void RevInorder(ThreadNode *T){
  	for(ThreadNode *p = Lastnode(T);p != NULL;p = Prenode(p))
  		visit(p);
  }
  ~~~

  ​	**先序线索二叉树找先序后继**：在先序线索二叉树中找到指定结点 *p的先序后继next

  ​													①若p->rtag==1，则next=p->rchild。

  ​													②若p->rtag==0，若p有左孩子，则先序后继为左孩子（*根*，<u>左</u>，右）->（*根*，（<u>根</u>，左，右），右）

  ​																					若p无左孩子，则先序后继为右孩子（*根*，<u>右</u>）->（*根*，（<u>根</u>，左，右））

  （相关代码与上面类似）

  ​	**先序线索二叉树找先序前驱**：在先序线索二叉树中找到指定结点 *p的先序前驱pre

  ​													①若p->ltag==1，则pre=p->lchild。

  ​													②若p->ltag==0，先序遍历中，左右子树中的结点只可能是根的后继，**不可能是前驱**。

  但是，改用三叉链表（增加一个父节点指针）可以找到父节点的情况下：

  1. p是左孩子，则p的父节点即为其前驱。（<u>根</u>，*左*，右）->（<u>根</u>，（*根*，左，右），右）
  2. p是右孩子，其左兄弟为空，则p的父节点即为其前驱。（<u>根</u>，*右*）->（<u>根</u>，（*根*，左，右））
  3. p是右孩子，其左兄弟非空，则p的前驱为左兄弟子树中最后一个被先序遍历的结点。（根，<u>左</u>，*右*）
  4. p是根节点，则p没有先序前驱。

  ​	**后序线索二叉树找后序前驱**：在后序线索二叉树中找到指定结点 *p的后序前驱pre

  ​													①若p->ltag==1，则pre=p->lchild。

  ​													②若p->ltag==0，若p有右孩子，则后序前驱为右孩子（左，<u>右</u>，*根*）->（左，（左，右，<u>根</u>），*根*）

  ​																					若p无右孩子，则后序前驱为左孩子（<u>左</u>，*根*）->（（左，右，<u>根</u>），*根*）

  （相关代码与上面类似）

  ​	**后序线索二叉树找后序后继**：在后序线索二叉树中找到指定结点 *p的后序后继next

  ​													①若p->rtag==1，则next=p->rchild。

  ​													②若p->rtag==0，后序遍历中，左右子树中的结点只可能是根的前驱，**不可能是后继**。

  但是，改用三叉链表（增加一个父节点指针）可以找到父节点的情况下：

  1. p是右孩子，则p的父节点即为其后继。（*左*，*右*，<u>根</u>）->（左，（左，右，*根*），<u>根</u>）
  2. p是左孩子，其右兄弟为空，则p的父节点即为其后继。（*左*，<u>根</u>）->（（左，右，*根*），<u>根</u>）
  3. p是左孩子，其右兄弟非空，则p的后继为右兄弟子树中第一个被后序遍历的结点。（*左*，<u>右</u>，根）
  4. p是根节点，则p没有后序后继。



## 树

- 逻辑结构

  **双亲表示法**（顺序存储）：每个结点中保存指向双亲的“指针”。

  ​	根节点固定存储在0；-1表示没有双亲，即根节点的“指针”就是-1。

  **孩子表示法**（顺序存储+链式存储）：顺序存储各个结点，每个结点中保存孩子链表头指针。

  **孩子兄弟表示法**（链式存储）：第一个孩子看作左指针，右兄弟看作右指针（兄弟当儿子）。（根节点是没有右指针的）

  ​	优点：可以用我们熟悉的二叉树操作来处理树。

- 森林和二叉树的转换：各个树的根节点视为兄弟关系。

- 树的先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历。

  树的**先根遍历序列**与这棵树相应的二叉树的**先序序列**相同。

- 树的后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根节点。

  树的**后根遍历序**列与这棵树相应的二叉树的**中序序列**相同。

- 树的层次遍历（用队列实现）

  1. 若树非空，则根节点入队。
  2. 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队。
  3. 重复（2）直到队列为空。

- 先根遍历和后根遍历为深度优先遍历，层次遍历为广度优先遍历。

- 先序遍历森林：若森林为非空，则按如下规则进行遍历：

  1. 访问森林中第一棵树的根节点。
  2. 先序遍历第一棵树中根节点的子树森林。
  3. 先序遍历除去第一课树之后剩余的树构成的森林。

  效果等同于依次对各个树进行先根遍历。或者依次对二叉树的先序遍历。

- 中序遍历森林：若森林为非空，则按如下规则进行遍历：

  1. 中序遍历森林中第一棵树的根节点的子树森林。
  2. 访问第一棵树的根节点。
  3. 中序遍历除去第一课树之后剩余的树构成的森林。

  效果等同于依次对各个树进行后根遍历。或者依次对二叉树的中序遍历。



## 哈夫曼树

- 结点的权：有某种现实含义的数值（如：表示结点的重要性等）。

- 结点的带权路径长度：从树的根到该节点的路径长度（经过的边数）与该节点上权值的乘积。

- **树的带权路径长度**：树中所有叶节点的带权路径长度之和。

- 在含有**n个带权叶节点**的二叉树中，其中**带权路径长度（WPL）最小**的二叉树称为**哈夫曼树**，也成为最优二叉树。

- 哈夫曼树的构造：

  1. 每个初始结点最终都成为叶节点，且**权值越小的结点到根节点的路径长度越大**。
  2. 哈夫曼树的结点总数为2n-1。
  3. 哈夫曼树中不存在度为1的结点。
  4. 哈夫曼树并不唯一，但WPL必然相同且为最优。

- 固定长度编码：每个字符用相等长度的二进制位表示。

  可变长度编码：允许对不同字符用不等长的二进制位表示。（若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码，前缀码解码无歧义）

- 由哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子节点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树。（哈夫曼树不唯一，因此哈夫曼编码也不唯一）



## 并查集

- 逻辑结构——“集合”。

- 用互不相交的树，表示多个“集合”：

  如何“查”到一个元素到底属于哪一个集合？——从指定元素出发，一路向北，找到根节点。

  如何判断两个元素是否属于同一个集合？——分别查到两个元素的根，判断根节点是否相同即可。

  如何把两个集合“并”为一个集合？——让一棵树成为另一棵树的子树即可。

- “并查集”的存储结构——双亲表示法

  集合的两个基本操作——“并”和“查”

  ​	Find——“查”操作：确定一个指定元素所属集合。

  ​	Union——“并”操作：将两个不相交的集合合并为一个。

  注：并查集是逻辑结构——集合的一种具体实现，只进行“并”和“查”两种基本操作。

- 代码实现：

  ~~~c
  #define SIZE 13
  int UFSets[SIZE];				//集合元素数组
  
  //初始化并查集
  void Initial(int S[]){
  	for(int i=0;i<SIZE;i++){
  		S[i]=-1;
  	}
  }
  
  //Find “查”操作，找x所属集合（返回x所属根节点）
  int Find(int S[],int x){
  	while(S[x]>=0){				//循环寻找x的根
  		x=S[x];
  	}
  	return x;					//根的S[]小于0
  }
  
  //Union “并”操作，将两个集合合并为一个
  void Union(int S[],int Root1,int Root2){
  	//要求Root1与Root2是不同的集合
  	if(Root1==Root2)	return;
  	//将根Root2连接到另一根Root1下面
  	S[Root2]=Root1;
  }
  ~~~

  若结点树为n，Find最坏时间复杂度为O(n);

  ​						 Union时间复杂度为O(1)。

  Union优化：

  优化思路：在每次Union操作构建树的时候，尽可能让树不长高。①用根节点的绝对值表示树的节点总数。②Union操作，让小树合并到大树。该方法构造的树高不超过(㏒₂n)+1。

  ~~~c
  //Union“并”操作，小树合并到大树
  int Union(int S[],int Root1,int Root2){
  	if(Root1==Root2)	return;
  	if(S[Root2]>S[Root1]){			//Root2结点数更少
  		S[Root1]+=S[Root2];			//累加结点总数
  		S[Root2]=Root1;				//小树合并到大树
  	}else{
  		S[Root2]+=S[Root1];			//累加结点总数
  		S[Root1]=Root2;				//小树合并到大树
  	}
  }
  ~~~

- 并查集的进一步优化

  ​	Find优化（压缩路径）——Find操作，先找到根节点，再将查找路径上所有结点都挂到根节点下。

  ​	每次Find操作，先找根，再“压缩路径”，可使树的高度不超过O(α(n))。α(n)是一个增长很缓慢的函数，对于常见的n值，通常α(n)≦4，因此优化后并查集的Find、Union操作时间开销都很低。

  ~~~c
  //Find“查”操作优化，先找到根节点，在进行“压缩路径”
  int Find(int S[],int x){
  	int root = x;
  	while(S[root] >= 0)	root S[root];	//循环找到根
  	while(x != root){					//压缩路径
  		int t = S[x]					//t指向x的父节点
  		S[x] = root;					//x直接挂到根节点下
  		x = t;
  	}
  	return root;						//返回根节点编号
  }
  ~~~

- | 最坏时间复杂度                           | 不优化 | Union优化 | Union+Find优化 |
  | ---------------------------------------- | :----: | :-------: | :------------: |
  | Find操作=最坏树高                        |  O(n)  |  O(㏒₂n)  |    O(α(n))     |
  | 将n个独立元素通过多次Union合并为一个集合 | O(n²)  | O(n㏒₂n)  |    O(nα(n))    |

  

