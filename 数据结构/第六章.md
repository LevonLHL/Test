# 第六章 图



## 图的定义

- 图G由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V={v₁，v₂，...，v(n)}，则用|V|表示图G中顶点的个数，也称图G的阶，E={(u,v)|u∈V,v∈V}，用|E|表示图G中边的条数。

  （注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集。）

- 无向图——无向边

  有向图——有向边（弧，没箭头的一端是弧尾，有箭头的一端是弧头）

- 简单图——①不存在重复边。②不存在顶点到自身的边。

  多重图——图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图。

- 对于无向图：顶点v的度是指依附于该顶点的边的条数，记为TD(v)。无向图全部顶点的度的和等于边数的2倍。

  对于有向图：**入度**是以顶点v为终点的有向边的数目，记为ID(v)；**出度**是以顶点v为起点的有向边的数目，记为OD(v)；**顶点v的度**等于其入度和出度之和，即TD(v)=ID(v)+OD(v)。
  
- 顶点的关系描述：

  **路径**——顶点v₁到顶点v₄之间的一条路径是指顶点序列；v₁，v₂，v₃，v₄。

  **回路**——第一个顶点和最后一个顶点相同的路径称为回路或环。

  **简单路径**——在路径序列中，顶点不重复出现的路径称为简单路径。

  **简单回路**——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。

  **路径长度**——路径上边的数目。

  **点到点的距离**——从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷。

  **无向图**中，若从顶点v到顶点w有路径存在，则称v和w是**连通**的。（顶点之间有可能不存在路径）

  **有向图**中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是**强连通**的。（有向图的路径也是有向的）

- 若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。

  对于n个顶点的无向图G：若G是连通图，则最少有n-1条边。若G是非连通图，则最多可能有C²（(n-1)为下标）条边。

- 若图中任何一对顶点都是强连通的，则称此图为强连通图。

  对于n个顶点的有向图G：若G是强连通图，则最少有n条边。（形成回路）

- 设有两个图G=(V,E)和G‘=(V’,E‘)，若V’是V的子集，且E‘是E的子集，则称G’是G的**子图**。

  若有满足V(G’)=V(G)的子图G‘，则称其为G的**生成子图**。（子图里包含了原图的所有顶点，可以去掉一些边）

- 无向图中的**极大连通子图**（子图必须连通，且包含尽可能多的顶点和边）称为**连通分量**。

- 有向图中的**极大强连通子图**（子图必须强连通，且包含尽可能多的边）称为**强连通分量**。

- 连通图的**生成树**是包含图中全部顶点的一个**极小连通子图**（边尽可能的少，但要保持连通）。

  若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。 

- 在非连通图中，连通分量的生成树构成了非连通图的**生成森林**。

- **边的权**——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的**权值**。

  **带权图/网**——边上带有权值的图称为带权图，也称为网。

  **带权路径长度**——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度。

- **无向完全图**——无向图中任意两个顶点之间都存在边。若无向图的顶点数为n，则边数为n(n-1)/2。

  **有向完全图**——有向图中任意两个顶点之间都存在方向相反的两条弧。若有向图的顶点数为n，则边数为n(n-1)。

- 边数很少的图称为**稀疏图**，反之称为**稠密图**。（没有绝对的界限，一般来说|E|<|V|㏒|V|时，可以将G视为稀疏图）

- **树**——不存在回路，且连通的无向图

  n个顶点的树，必有n-1条边。

  常见考点：n个顶点的图，若|E|>n-1，则一定有回路。

- **有向树**——一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树。



## 图的存储

- **邻接矩阵法**

  用0表示顶点之间无连接，1表示顶点之间相互连接（无向图中每个边对应两个1），构成一个方阵。代码实现：

  ~~~c
  #define MaxVertexNum 100			//顶点数目的最大值
  typedef struct{
  	char Vex[MaxVertexNum];						//顶点表
  	int Edge[MaxVertexNum][MaxVertexNum];		//邻接矩阵，边表
  	int vexnum,arcnum;							//图的当前顶点数和边数\弧数
  } MGraph;
  ~~~

  顶点中还可以存放更复杂的信息。还可以用bool型或枚举型变量表示邻接矩阵，以减少内存开销。

  无向图：第i个结点的度=第i行（或第i列）的非零元素个数。

  有向图：

  ​	第i个结点的出度=第i行的非零元素个数。

  ​	第i个结点的入度=第i列的非零元素个数。

  ​	第i个结点的度=第i行、第i列的非零元素个数之和。

  邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(n)。

- 邻接矩阵法存储带权图（网）：可用权值代替“1”来存储，用∞代替“0”，也可以用0。（可用int的上限值表示“无穷”）

  空间复杂度:O(n²)——只和顶点数相关，和实际的边数无关。

  适合存储稠密图。

  无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区\下三角区）。

- 设图G的邻接矩阵为A（矩阵元素为0\1），则A^n的元素
  $$
  (A^n)[i][j]
  $$
  等于由顶点i到顶点j的长度为n的路径的数目。

  例：`A²[1][4]`=a(1,1)a(1,4)+a(1,2)a(2,4)+a(1,3)a(3,4)+a(1,4)a(4,4)；`A²[2][2]`=a(2,1)a(1,2)+a(2,2)a(2,2)+a(2,3)a(3,2)+a(2,4)a(4,2)

- **邻接表法**（顺序+链式存储）

  与树的孩子表示法相同，各个结点顺序存储，再用链表指明与结点相连的边。

  对于无向图，边结点的数量是2|E|，整体空间复杂度为O(|V|+2|E|)。（会产生两份冗余的数据）

  对于有向图，边结点的数量是|E|，整体空间复杂度为O(|V|+|E|)。

  **图的邻接表表示方式并不唯一。只要确定了顶点编号，图的邻接矩阵表示方式唯一。**

  |                  | 邻接表                                      | 邻接矩阵           |
  | ---------------- | ------------------------------------------- | ------------------ |
  | 空间复杂度       | 无向图O(\|V\|+2\|E\|)；有向图O(\|V\|+\|E\|) | O(\|V\|²)          |
  | 适合用于         | 存储稀疏图                                  | 存储稠密图         |
  | 表示方式         | 不唯一                                      | 唯一               |
  | 机算度/出度/入度 | 机算有向图的度、入度不方便，其余很方便      | 必须遍历对应行或列 |
  | 找相邻的边       | 找有向图的入边不方便，其余很方便            | 必须遍历对应行或列 |

- **十字链表法**（存储有向图）

  在邻接表的基础上再加一条指针链，指向入度的结点。

  空间复杂度：O(\|V\|+\|E\|)。

  十字链表只用于存储有向图。可以解决有向图的度、入度、入边不方便的问题。

- **邻接多重表**（存储无向图）

  与十字链表法相似。

  空间复杂度：O(\|V\|+\|E\|)。

  邻接多重表只用于存储无向图。可以解决无向图空间复杂度太高和存储冗余信息的问题，另外删除边、删除结点等操作也会很方便。

  十字链表法和邻接多重表表示方式都不唯一。

- 图的基本操作：<>表示有向边，()表示无向边。

  Adjacent(G,x,y)：判断图G是否存在边<x,y>或(x,y)。

  Neighbors(G,x)：列出图G中与结点x邻接的边。

  InsertVertex(G,x)：在图G中插入顶点x。

  DeleteVertex(G,x)：从图G中删除顶点x。

  AddEdge(G,x,y)：若无向边(x,y)或有向边<x,y>不存在，则图G中添加该边。

  FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。

  NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。



## 图的遍历

- 广度优先遍历（BFS）

  类似树的层次遍历。

  1. 找到与一个顶点相邻的所有顶点。
  2. 标记哪些顶点被访问过，防止重复访问。（可以是bool型数组）
  3. 需要一个辅助队列。

  同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一；同一个图的邻接表表示方式不唯一，因此广度优先遍历序列不唯一。

  对于无向图，调用BFS函数的次数=连通分量数。

  **邻接矩阵存储的图**：

  ​	访问|V|个顶点需要O(|V|)的时间。

  ​	查找每个顶点的邻接点都需要O(|V|)的时间，而总共有|V|个顶点。

  ​	**时间复杂度=O(|V|²)**。

  **邻接表存储的图**：

  ​	访问|V|个顶点需要O(|V|)的时间。

  ​	查找各个顶点的邻接点共需要O(|E|)的时间。

  ​	**时间复杂度=O(|V|+|E|)**。

  **广度优先生成树**是由广度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一。

  对非连通图的广度优先遍历，可得到广度优先生成森林。

- 深度优先遍历（DFS）

  类似树的先根遍历。

  对于无向图，调用DFS函数的次数=连通分量数。

  空间复杂度：来自函数调用栈，最坏情况，递归深度为O(|V|)。

  时间复杂度与广度优先遍历一样。

  同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一；同一个图的邻接表表示方式不唯一，因此广度优先遍历序列不唯一。

  **深度优先生成树**是由深度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的深度优先生成树也不唯一。

  对非连通图的深度优先遍历，可得到深度优先生成森林。

  对有向图进行BFS/DFS遍历，若起始顶点到其他各顶点都有路径，则只需调用1次BFS/DFS函数。对于强连通图，从任一结点出发都只需调用1次BFS/DFS函数。



## 最小生成树

- 对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的**权值之和最小的生成树**，则T称为G的**最小生成树**（MST）。（或最小代价树）

- 最小生成树可能有多个，但边的权值之和总是唯一且最小的。

- 最小生成树的边数=顶点数-1.砍掉一条则不连通，增加一条边则会出现回路。

- 如果一个连通图本身就是一棵树，则其最小生成树就是他本身。

- 只有连通图才有生成树，非连通图只有生成森林。

- Prim算法（普里姆）：从某一个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。

  时间复杂度：O(|V|²)。

  适合用于边稠密图。

  算法实现：

  ​	初始化两个数组：isJoin[]标记各节点是否加入数；lowCost[]各节点加入树的最低代价。

  ​	每一轮遍历处理：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。

  ​	再次循环遍历，更新还没加入的各个顶点的lowCast值。

- Kruskal算法（克鲁斯卡尔）：每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选），直到所有结点能连通。

  时间复杂度：O(|E|㏒₂|E|)。

  适合用于边稀疏图。

  算法实现：

  ​	初始：将各条边按权值排序。

  ​	每一轮：检查第一条边的两个顶点是否连通（是否属于同一个集合）。连通则跳过，不连通则连起来。

  ​	共执行E轮。



## 最短路径问题

- **BFS算法**

  用于**无权图的单元最短路径**。

  就是对BFS的小修改，在visit一个顶点时，修改其最短路径长度d[]并在path[]记录前驱节点。

- **Dijkstra算法**

  用于**带权图、无权图的单元最短路径**。

  初始：从V₀开始，初始化三个数组final[]标记各顶点是否已找到最短路径，dist[]最短路径长度，path[]路径上的前驱。

  每一轮：循环遍历所有节点，找到还没确定最短路径，且dist最小的顶点V(i)，令final[i]=true。

  ​			  检查所有邻接自V(i)的顶点，若其final值为false，则更新dist和path信息。

  时间复杂度：O(|V|²)。

  Dijkstra算法不适用于有负权值的带权图。

- **Floyd算法**

  用于**带权图、无权图的各顶点间最短路径**。

  对于n个顶点的图G，求任意一对顶点V(i)->V(j)之间的最短路径可分为如下几阶段：

  ​	初始：不允许在其他顶点中转的最短路径。

  ​	第0轮：若允许在V₀中转的最短路径。(顶点从V₀开始编号)

  ​	第1轮：若允许在V₀、V₁中转的最短路径。

  ​	......

  ​	第n-1轮：若允许在V₀、V₁...V(n-1)中转的最短路径。

  从A^(-1)和path^(-1)开始，经过n轮递推，得到A^(n-1)和path^(n-1)。（矩阵A存储各顶点间的最短路径长度，矩阵path存储两个顶点之间的中转点）

  ~~~c
  //...准备工作，根据图的信息初始化矩阵A和path
  for(int k=0;k<n;k++){							//考虑以V(k)作为中转点
  	for(int i=0;i<n;i++){						//遍历整个矩阵，i为行号，j为列号
  		for(int j<0;j<n;j++){
  			if(A[i][j]>A[i][k]+A[k][j]){		//以V(k)为中转点的路径更短
  				A[i][j]=A[i][k]+A[k][j];		//更新最短路径长度
  				path[i][j]=k;					//中转点
  			}
  		}
  	}
  }
  ~~~

  时间复杂度：O(|V|³)。

  空间复杂度：O(|V|²)。

  Floyd算法可解决有负权值的带权图，但不能解决带有“负权回路”的图，这种图有可能没有最短路径。



## 有向无环图描述表达式

- 有向无环图：若一个有向图中不存在环，则称为有向无环图，简称为DAG图。

- 顶点中不可能有重复的操作数。

- 解题方法：

  1. 把各个操作数不重复地排成一排。
  2. 标出各个运算符的生效顺序（先后顺序有点出入没关系）
  3. 按顺序加入运算符，注意“分层”。
  4. 从底向上逐层检查同层的运算符是否可以“合体”。

- 结果不唯一。

- **拓扑排序**：

  ​	AOV网（用于顶点表示活动的网）：用DAG图表示一个工程，顶点表示活动，有向边<V(i),V(j)>表示活动V(i)必须先于活动V(j)进行。

  ​	找到做事的先后顺序。

  ​	每个AOV网都有一个或多个拓扑排序序列。

  ​	实现方式：

  1. 从AOV网中选择一个没有前驱（入度为0）的顶点并输出。
  2. 从网中删除该顶点和所有以它为起点的有向边。
  3. 重复（1）和（2）直到当前的**AOV网为空**或**当前网中不存在无前驱的顶点为止**（说明有回路）。

  ​    代码实现：

  ​	需先定义indegree[]用于当前顶点入度，print[]记录拓扑序列，栈S保存度为0的顶点（也可用队列或数组）。

  ~~~c
  bool TopologicalSort(Graph G){
  	InitStack(S);									//初始化栈，存储入度为0的顶点
  	for(int i=0;i<G.vexnum;i++)
  		if(indegree[i]==o)
  			Push(S,i);								//将所有入度为0的顶点进栈
  	int count=0;									//计数，记录当前已经输出的顶点数
  	while(!IsEmpty(S)){								//栈不空，则存在入度为0的顶点
  		Pop(S,i);									//栈顶点元素出栈
  		print[count++]=i;							//输出顶点i
  		for(p=G.vertices[i].firstarc;p;p=p->nextarc){
  			//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S
  			v=p->adjvex;
  			if(!(--indegree[v]))
  				Push(S,v);							//入度为0，则入栈
  		}
  	}
  	if(count<G.vexnum)
  		return false;								//排序失败，有向图中有回路
  	else
  		return true;								//拓扑排序成功
  }
  ~~~

  由于每个顶点都需要处理一次，每条边都需要处理一次，所以时间复杂度为O(|V|+|E|)，若采用邻接矩阵，则需O(|V|²)。

- **逆拓扑排序**：

  ​	对一个AOV网，如果采用下列步骤进行排序，则称之为逆拓扑排序：

  1. 从AOV网中选择一个没有后继（出度为0）的顶点并输出。
  2. 从网中删除该顶点和所有以它为终点的有向边。
  3. 重复（1）和（2）直到当前的**AOV网为空**。

  ​    逆邻接表：每个顶点的对应信息是指向该顶点的边。

  ​	逆拓扑排序的实现（DFS算法）：

  ~~~c
  void DFSTraverse(Graph G){				//对图G进行深度优先遍历
  	for(v=0;v<G.vexnum;++v)
  		visited[v]=FALSE;				//初始化已访问标记数据
  	for(v=0;v<G.vexnum;++v)				//本代码中是从v=0开始遍历
  		if(!visited[v])
  			DFS(G,v);
  }
  void DFS(Graph G,int v){				//从顶点v出发，深度优先遍历图G
  	visited[v]=TRUE;					//设已访问标记
  	for(w=FirstNeighbor(G,v);w>=0;w=NextNeighor(G,v,w))
  		if(!visited[w]){				//w为u的尚未访问的邻接顶点
  			DFS(G,w);
  		}
  	print(v);							//在顶点退栈前输出
  }
  ~~~

  拓扑排序、逆拓扑排序序列可能不唯一。

  若图中有环，则不存在拓扑排序序列和逆拓扑排序序列。

- **关键路径**：

  ​	在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。

  ​	AOE网具有以下两个性质：

  1. 只有在某个顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。
  2. 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。

  ​    在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。

  ​	从源点到汇点的有向路径可能有多条，所有路径中，**具有最大路径长度的路径称为关键路径**，而把**关键路径上的活动称为关键活动**。

  ​	完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。

  ​	**事件V(k)的最早发生时间ve(k)**——决定了所有从v(k)开始的活动能够开工的最早时间。

  ​		按拓扑排序序列，依次求各个顶点的ve(k)：ve（源点）=0，ve(k)=Max{ve(j)+weight(v(j),v(k))}，v(j)为v(k)的任意前驱。

  ​	**活动a(i)的最早开始时间e(i)**——指该活动弧的起点所表示的事件的最早发生时间。

  ​		若边<v(k),v(j)>表示活动a(i)，则有e(i)=ve(k)。

  ​	**事件V(k)的最迟发生时间vl(k)**——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。

  ​		按逆拓扑排序序列，依次求各个顶点的vl(k)：vl（汇点）=ve（汇点），vl(k)=Min{vl(j)-weight(v(k),v(j))}，v(j)为v(k)的任意后继。

  ​	**活动a(i)的最迟开始时间l(i)**——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。

  ​		若边<v(k),v(j)>表示活动a(i)，则有l(i)=vl(j)-Weight(v(k),v(j))。

  ​	**活动a(i)的时间余量d(i)=l(i)-e(i)**，表示在不增加完成整个工程所需总时间的情况下，活动a(i)可以拖延的时间。

  ​		d(i)=l(i)-e(i)。

  ​	若一个活动的时间余量为0，则说明该活动必须要如期完成，d(i)=0即l(i)=e(i)的活动a(i)是关键活动。

  ​	由关键活动组成的路径就是关键路径。

  ​	若关键活动耗时增加，则整个工程的工期将增加。缩短关键活动的时间，可以缩短整个工程的工期。**当缩短到一定程度时，关键活动可能会变成非关键活动**。

  ​	**可能有多条关键路径**，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的 关键活动才能达到缩短工期的目的。

