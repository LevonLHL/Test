# 第四章 串



## 串

- 字符串（String）是由零个或多个字符组成的有限序列。

- S是**串名**，单引号（有的语言用双引号）括起来的字符序列是串的值；a(i)可以是字母、数字或其他字符；串中字符的个数n称为串的长度。n=0时的串称为**空串**。

- **子串**：串中任意个连续的字符组成的子序列。

- **主串**：包含子串的串。

- 字符在主串中的位置：字符在串中的序号。（位序从1开始而不是从0开始）

- 子串在主串中的位置：子串的第一个字符在主串中的位置。

- 串是一种特殊的线性表，数据元素之间呈线性关系。

- 串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）。

- 串的基本操作，如增删改查等通常以子串为操作对象。

  假设有串T="",S="iphone 11 Pro Max?",W="Pro":

  StrAssign(&T,chars)：赋值操作。把串T复制为chars。

  StrCopy(&T,S)：复制操作。由串S复制得到串T。

  StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。

  StrLength(S)：求串长。返回串S的元素个数。

  ClearString(&S)：清空操作。将S清为空串。

  DestroyString(&S)：销毁串。将串S销毁（回收存储空间）。

  Concat(&T,S1,S2)：串连接。用T返回由S1和S2连接而成的新串。

  SubString(&Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。

  **Index(S,T)**：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则返回值为0。

  **StrCompare(S,T)**：比较操作。若S>T，则返回值>0；若S=T，则返回值=0；若S<T，则返回值<0。（从第一个字符开始往后依次对比，先出现更大字符的串就更大）

- 字符集编码：每个字符在计算机中对应一个二进制数，比较字符的大小其实就是比较二进制数的大小。



## 串的存储结构

- 串的顺序存储：

  ​	静态数组实现（定长顺序存储）：分配连续的存储空间，每个char字符占1B，外加串的实际长度length。

  ​	动态数组实现（堆分配存储）：用完需要手动free。
  
- 串的链式存储：存储密度低：每个字符1B，每个指针4B。解决方案：可以每个节点改成数组多存几个字符，没有字符的位置用'#'或'\0'补足。



## 朴素模式匹配算法

- 字符串模式匹配：在主串(S)中找到与**模式串(T)**（不一定能在主串中找到）相同的子串，并返回其所在的位置。

- 朴素模式匹配算法：主串长度为n，模式串长度为m的情况下

  ​	将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都匹配不上为止。

- 实现：①分别设立主串指针(i)和模式串指针(j)在主串和模式串上，指针同时后移将主串中所有长度为m的子串与模式串对比，若当前子串匹配失败，则主串指针i指向下一个子串的第一个位置(i=i-j+2)，模式串指针j回到模式串的第一个位置(j=1)。若j>T.length，则当前子串匹配成功，返回当前子串第一个字符的位置——i-T.length。若所有子串都不匹配，则返回0。

  ​			设主串长度为n，模式串长度为m，则最坏时间复杂度=O(nm)。

  ​			②还可用Index(S,T)实现。



## KMP算法

- 根据朴素模式匹配算法思想，不匹配的的字符之前，一定是和模式串一致的。

- 对于模式串T='abaabc'，当第6个元素匹配失败时，可令主串指针i不变，模式串指针j=3。

  ​										  当第5个元素匹配失败时，可令主串指针i不变，模式串指针j=2。

  ​										  当第4个元素匹配失败时，可令主串指针i不变，模式串指针j=2。

  ​										  当第3个元素匹配失败时，可令主串指针i不变，模式串指针j=1。

  ​										  当第2个元素匹配失败时，可令主串指针i不变，模式串指针j=1。

  ​										  当第1个元素匹配失败时，匹配下一个相邻子串，令j=0,i++,j++。

  ​										（对模式串具有通用性，和主串无关系 ）

  优化后主串指针不回溯。

  next数组：

  | next[0] | next[1] | next[2] | next[3] | next[4] | next[5] | next[6] |
  | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
  |         | 0       | 1       | 1       | 2       | 2       | 3       |

  ```
  if(S[i] != T[j])
  j = next[j];
  if(j == 0)
  {
  i++;
  j++;
  }
  ```

  

- 根据模式串T求出next数组，然后利用next数组进行匹配（主串指针不回溯）。

- next数组只和短短的模式串有关，和长长的主串无关。

- KMP算法，最坏时间复杂度O(m+n)

  其中，求next数组时间复杂度O(m)

  模式匹配过程最坏时间复杂度O(n)



## 求模式串的next数组

- next数组的作用：当模式串的第j个字符失配时，从模式串的第next[j]继续往后匹配。
- 任何模式串都一样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，next[2]都无脑写1，next[1]都无脑写0。
- 在不匹配的位置前边，划一根分界线，模式串一步步后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时j指向哪里，next数组值就是多少。



## KMP算法的优化

- 根据模式串T，求出next数组->利用next数组进行匹配（主串指针不回溯）->使用nextval数组

- 先求next数组，再由next数组求nextval数组。

  | 序号j      | 1    | 2    | 3    | 4    | 5    | 6    |
  | ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 模式串     | a    | b    | a    | b    | a    | a    |
  | next[j]    | 0    | 1    | 1    | 2    | 3    | 4    |
  | nextval[j] | 0    | 1    | 0    | 1    | 0    | 4    |

- 在模式串与主串失配的情况下，说明主串这个字符一定不是模式串的当前字符，所以可以让当前next[j]的值等于最早出现此字符时next[j]的值。

