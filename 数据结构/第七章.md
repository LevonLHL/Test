# 第七章 查找



## 查找的基本概念

- **查找**——在数据集合中寻找满足条件的数据元素的过程称为查找。

- **查找表**（查找结构）——用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。

- **关键字**——数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。

- 常见操作：查找符合条件的数据元素（仅关注查找速度即可）——静态查找表

  ​					插入、删除某个数据元素（除了查找速度，也要关注插/删操作是否方便实现）——动态查找表

- **查找长度**——在查找运算中，需要对比关键字的次数称为查找长度。

- **平均查找长度**（ASL）——所有查找过程中进行关键字的比较次数的平均值。通常认为查找任何一个元素的概率都相同。

  评价一个查找算法的效率时，通常考虑查找成功和操作失败两种情况的ASL。

  ASL的数量级反应了查找算法时间复杂度。

- **顺序查找**：又称“线性查找”，通常用于线性表。

  从头到脚依次查找。表中元素有序无序都行。

  可在0号位置存“哨兵”，从尾部向头部挨个查找。优点：循环时无需判断下标是否越界。

  优化：①若表中元素有序：

  ​			1、当前关键字大于（或小于）目标关键字时，查找失败。优点：查找失败时ASL更少。

  ​			2、查找判定树。成功节点的关键字对比次数=节点所在层数；失败节点的关键字对比次数=其父节点所在层数。

  ​			②若各个关键字被查概率不同：可按被查概率降序排列。优点：查找成功时ASL更少。

  **时间复杂度：O(n)**。

- **折半查找**：又称“二分查找”，仅适合于有序的顺序表（顺序表拥有随机访问的特性，链表没有）。

  mid=(low+high)/2

  如果当前low和high之间有**奇数个**元素，则mid分隔后，**左右两部分元素个数相等**。

  如果当前low和high之间有**偶数个**元素，则mid分隔后，**左半部分比右半部分少一个元素**。

  折半查找的判定树中，若mid=(low+high)/2，则对于任何一个节点，必有：**右子树结点数-左子树结点数=0或1**。（向下取整为例，向上取整则正好相反）

  折半查找判定树**一定是平衡二叉树**，且**只有最下面一层是不满的**。因此，元素个数为n时**树高h=㏒₂(n+1)**。

  判定树结点关键字：**左<中<右**，满足二叉排序树的定义。

  **失败节点：n+1个（**等于成功结点的空链域数量）。

  **折半查找的时间复杂度：O(㏒₂n)**。

- **分块查找**：又称索引顺序查找。

  “索引表”中保存每个分块的最大关键字和分块的存储区间。

  特点：**块内无序，块间有序**。

  算法过程：①在索引表中确定待查记录所属的**分块（可顺序、可折半）**。②在块内顺序查找。

  若索引表中不包含目标关键字，则折半查找索引表最终停在low>high，要**在low所指分块中查找**。（原因：最终low左边一定小于目标关键字，high右边一定大于目标关键字。而分块查找的索引表中保存的是各个分块的最大关键字。）

  low超出索引表范围则查找失败。

  假设，长度为n的查找表被均匀的分为b块，每块s个元素：

  ​	设索引查找和块内查找的平均查找长度分别为L(i)，L(s)，则分块查找的平均查找长度为ASL=L(i)+L(s)。

  ​	用顺序查找差索引表，则L(i)=(b+1)/2，L(s)=(s+1)/2，则ASL=[(b+1)/2]+[(s+1)/2]=(s²+2s+n)/2s。**当s=√n时，ASL最小=（√n）+1**。

  ​	用折半查找查索引表，则L(i)=㏒₂(b+1)，L(s)=(s+1)/2。则ASD=㏒₂(b+1)+(s+1)/2。



## 二叉排序树

- 二叉排序树，又称二叉查找树（BST）。可用于元素的有序组织、搜索。

- **左子树结点值<根节点值<右子树结点值**。（进行中序遍历，可以得到一个递增的有序序列）

- **二叉排序树的查找**：①若树非空，目标值与根节点的值比较；

  ​								   ②若相等，则查找成功；

  ​								   ③若小于根节点，则在左子树上查找，否则在右子树上查找。

  查找成功，返回结点指针；查找失败返回NULL。

- **二叉排序树的插入**：若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树。（插入的一定是在叶子节点）

- **二叉排序树的删除**：先搜索找到目标节点：

  ​	①若被删除结点z是叶子节点，则直接删除，不会破坏二叉排序树的性质。

  ​	②若结点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，替代z的位置。

  ​	③若结点z有左、右两颗子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了①或②的情况。

- **查找长度**——在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。（若树高h，找到最下层的一个结点需要对比h次）

  **查找成功的平均查找长度ASL**=层数乘该层结点的个数之和除结点总数。

  **查找失败的平均查找长度ASL**=层数乘该层下一层未插入结点的个数之和除未插入结点总数。



## 平衡二叉树

- **平衡二叉树**（AVL树）：树上任一结点的左子树和右子树的深度之差不超过1。

  结点的平衡因子=左子树高-右子树高。（平衡二叉树结点的平衡因子的值只可能是-1、0、1）

  ​	问：在二叉排序树中插入新节点后，如何保持平衡？

  ​	答：从插入点往回找到第一个不平衡结点，调整以该节点为根的子树。（每次调整的对象都是“最小不平衡子树”）

- **调整最小不平衡子树**：

  1. **LL平衡旋转**（**右单旋转**）。由于在结点A的左孩子（L）的左子树（L）上插入了新节点，A的平衡因子由1增加至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子**B向右上旋转**代替A成为根节点，将**A结点向右下旋转**成为B的右子树的根节点，而B的原右子树则作为A结点的左子树。
  2. **RR平衡旋转**（**左单旋转**）。由于在结点A的右孩子（R）的右子树（R）上插入了新节点，A的平衡因子由-1减少至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的右孩子**B向左上旋转**代替A成为根节点，将**A结点向左下旋转**成为B的左子树的根节点，而B的原左子树则作为A结点的右子树。
  3. **LR平衡旋转**（**先左后右双旋转**）。由于在结点A的左孩子（L）的右子树（R）上插入了新节点，A的平衡因子由1增加至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A的左孩子B的右子树的根节点**C向左上旋转提升到B结点的位置**，然后再把该**C结点向右上旋转提升到A结点的位置**。
  4. **RL平衡旋转**（**先右后左双旋转**）。由于在结点A的右孩子（R）的左子树（L）上插入了新节点，A的平衡因子由-1减少至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A的右孩子B的左子树的根节点**C向右上旋转提升到B结点的位置**，然后再把该**C结点向左上旋转提升到A结点的位置**。

- 假设以n(h)表示深度为h的平衡树中含有的最少结点数。则有n₀=0，n₁=1，n₂=2，并且有n(h)=n(h-1)+n(h-2)+1。（括号里为下标）

  可以证明含有n个结点的平衡二叉树的最大深度为O(㏒₂n)，平衡二叉树的平均查找长度为O(㏒₂n)。

- **平衡二叉树的删除操作**：

  1. 删除结点。（方法同“二叉排序树”）
     - 若删除的结点是叶子结点，直接删。
     - 若删除的结点只有一个子树，用子树顶替删除位置。
     - 若删除的结点有两棵子树，用前驱或后继结点顶替（复制数据即可），并转换为对前驱或后继结点的删除。
  2. 一路向北找到最小不平衡子树。找不到就完结撒花。
  3. 找最小不平衡子树下，“个头”最高的儿子、孙子。
  4. 根据孙子的位置，调整平衡（LL/RR/LR/RL）。
  5. 如果不平衡向上传导，继续（2）。

  平衡二叉树删除操作时间复杂度=O(㏒₂n)。



## 红黑树

- **红黑树（RBT）**：插入和删除很多时候不会破坏“红黑特性”，无需频繁调整树的形态。即便需要调整，一般都可以**在常数级时间内完成**。

- 红黑树是二叉排序树（BST）：左子树结点值≦根节点值≦右子树结点值。

  与普通BST相比：①每个结点或是红色，或是黑色。

  ​							  ②根节点是黑色的。

  ​							  ③叶节点（外部节点、NULL结点、失败结点）均是黑色。

  ​							  ④不存在两个相邻的红节点（即红节点的父节点和孩子结点均是黑色）。

  ​							  ⑤对每个结点，从该节点到任一叶节点的简单路径上，说含黑节点的数目相同。

  **左根右，根叶黑。不红红，黑路同。**

- 红黑树的定义：

  ~~~c
  struct RBnode{			//红黑树的结点定义
  	int key;			//关键字的值
  	RBnode* parent;		//父节点指针
  	RBnode* lchild;		//左孩子指针
  	RBnode* rchild;		//右孩子指针
  	int color;			//结点颜色，如：可用 0/1 表示 黑/红，也可使用枚举型enum表示颜色
  }
  ~~~

- 结点的**黑高**bh——从某结点出发（不含该结点）到达任一空叶节点的路径上黑节点总数。

- 性质：

  1. 从根节点到叶节点的最长路径不大于最短路径的2倍。

  2. 有n个内部结点的红黑树高度h≦2㏒₂(n+1)。

     若根节点黑高为h，内部节点数（关键字）最少有(2^h)-1个。（满树形态）

  3. 红黑树查找操作时间复杂度=O(㏒₂n)。（查找效率与AVL树同等数量级）

- 红黑树的查找：与BST、AVL相同，从根节点出发，左小右大，若查找到一个空叶节点，则查找失败。

- **红黑树的插入**：

  1. 先查找，确定插入的位置（原理同二叉排序树），插入新节点。

  2. 新节点是根——染为黑色。

     新节点是非根——染为红色。

  3. 若插入新节点后依然满足红黑树的定义，则插入结束。

     若插入新节点后不然满足红黑树的定义，需要调整（看新节点的叔叔的颜色），使其重新满足红黑树定义。

     - 黑叔：旋转+染色

       LL型：右单旋，父换爷+染色。

       RR型：左单旋，父换爷+染色。

       LR型：左、右双旋，儿换爷+染色。

       RL型：右、左双旋，儿换爷+染色。

     - 红叔：染色+变新

       叔父爷染色，爷变为新节点。

- 红黑树的删除：

  ​	红黑树删除操作的时间复杂度=O(㏒₂n)。

  ​	在红黑树中删除节点的处理方式和“二叉排序树的删除”一样。

  ​	按“二叉排序树的删除”删除节点后，可能破坏“红黑树特性”，此时需要调整结点颜色、位置，使其再次满足“红黑树特性”。



## B树

- 5叉查找树：最少1个关键字，2个分叉；最多4个关键字，5个分叉。节点内关键字有序。

  若每个节点内关键字太少，导致树变高，要查更多层结点，效率低。所以**在m叉查找树中，规定除了根节点外，任何结点至少有m/2个分叉，即至少含有(m/2)-1个关键字**。

  **m叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同**。

- **B树**，又称**多路平衡查找树**，B树中所有结点的孩子个数的最大值称为**B树的阶（分叉的最大值）**，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：

  1. 树中每个节点至多有m棵子树，即至多含有m-1个关键字。
  2. 若根节点不是终端节点，则至少有两棵子树。
  3. 除根节点外的所有非叶子结点至少有m/2棵子树，即至少含有(m/2)-1个关键字。
  4. 所有的**叶节点都出现在同一层次上，并且不带信息**（可以视为外部节点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，**指向这些结点的指针为空**）。**带信息的最底层结点称为终端节点。**

- 含n个关键字的m阶B树，最小高度、最大高度是多少？

  ​	最小高度——让每个结点尽可能的满，有m-1个关键字，m个分叉，则有n≦(m^h)-1，因此h≧㏒(m为底)(n+1的对数)。

  ​	最大高度——让各层的分叉尽可能的少，即根节点只有2个分叉，其他结点只有m/2个分叉。第h+1层共有叶子节点（失败节点）2(m/2)^(h-1)个。**n个关键字的B树必有n+1个叶子节点**，则n+1≧2(m/2)^(h-1)，即h≦㏒(m/2为底)(((n+1)/2)+1为对数)。

- **B树的插入**：(以下m/2都是向上取整的情况)

  ​	在插入key后，若导致原结点关键字数超过上限，则从中间位置m/2将其中的关键字分为两部分，**左部分包含的关键字放在原结点中，右部分包含的关键字放到新节点中，中间位置m/2的结点插入原结点的父节点。**若此时导致父节点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根节点为止，进而导致B树高度增加1。

  ​	**新元素一定是插入到最底层“终端节点”，用“查找”来确定插入的位置。**

- **B树的删除**：

  ​	若被删除关键字在**终端节点**，则**直接删除该关键字**（要注意结点关键字个数是否低于下限(m/2)-1）。

  ​	若被删除关键字在**非终端节点**，则用**直接前驱或直接后继来替代被删除的关键字**。（直接前驱：当前关键字左侧指针所指子树中“最右下”的元素；直接后继：当前关键字右侧指针所指子树中“最左下”的元素）

  ​	对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作。

  ​	若结点关键字个数低于下限，分一下几种情况：

  1. 兄弟够借。当兄弟很宽裕时，调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法）。（当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺；当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺）

     本质：要永远保证 子树0<关键字1<子树1<关键字2<子树2<...

  2. 兄弟不够借。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该节点相邻的左、右兄弟结点的关键字个数均=(m/2)-1，则将关键字删除后**与左（或右）兄弟结点及双亲结点中的关键字进行合并**。在合并过程中，双亲结点中的关键字个数会减1。若双亲结点是根结点且关键字个数减少至0（根节点关键字个数为1时，有两棵子树），则直接将根节点删除，合并后的新节点成为根；若双亲结点不是根节点，且关键字个数减少到(m/2)-2，则又要与它自己的兄弟节点进行调整或合并操作，并重复上述操作，直至符合B树的要求为止。

- **B+树**：（分块查找的进化->多级分块查找）

  一棵m阶的B+树需满足下列条件：

  1. 每个分支结点最多有m棵子树（孩子结点）。
  2. 非叶根结点至少有两棵子树，其他每个分支结点至少有m/2棵子树。
  3. **结点的子树个数与关键字个数相等**。
  4. 所有**叶节点包含全部关键字**及指向相应记录的指针，叶节点中将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互链接（支持顺序查找）起来。
  5. 所有**分支节点**中仅包含它的各个子节点中**关键字的最大值**及指向其子结点的指针。

  B+树的查找：多路查找、顺序查找。

  **B+树中，无论查找成功与否，最终一定都要走到最下面一层结点。**

  在B+树中，非叶节点不含有该关键字对应记录的存储地址。可以使一个磁盘块包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快。

  B树与B+树的相同点：除根节点外，最少m/2个分叉（确保结点不要太“空”），任何一个结点的子树都要一样高（确保“绝对平衡”）。



## 散列查找

- **散列表**（Hash Table），又称**哈希表**。是一种数据结构，特点是：数据元素的**关键字与其存储地址直接相关**。通过“**散列函数**（哈希函数）”：Addr=H(key)。

  若不同的关键字通过散列函数映射到同一个值，则称它们为“**同义词**”。通过散列函数确定的位置已经存放了其他元素，则称这种情况为“**冲突**”。

- 用**拉链法**（又称链接法、链地址法）处理“冲突”：**把所有“同义词”存储在一个链表中**。

  散列查找：通过散列函数机算目标元素存储地址：Addr=H(key)。然后进行顺序查找。

  冲突越多，查找效率越低。

  拉链法的小优化：在插入新元素时，保持关键字有序，可微微提高查找效率。

- **装填因子α=表中记录数/散列表长度**，装填因子会直接影响散列表的查找效率。

- 常见的散列函数：设计目标——让不同关键字的冲突尽可能地少。

  **除留余数法——H(key)=key % p**。散列表表长为m，取一个不大于m但最接近或等于m的**质数**p（用质数取模，分布更均匀，冲突更少）。

  **直接定址法——H(key)=key或H(key)=a * key + b**。其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它**适合关键字的分布基本连续的情况**，若关键字分布不连续，空位较多，则会造成存储空间的浪费。（例如学号）

  **数字分析法——选取数码分布较为均匀的若干位作为散列地址**。设关键字是r进制数（如十进制数），而**r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些**，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。（例如手机号）

  **平方取中法——取关键字的平方值的中间几位作为散列地址。**具体取多少位要视情况而定。**这种方法得到的散列地址与关键字的每位都有关系**，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。（例如身份证号 ）

- 散列查找是典型的“**用空间换时间**”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。

- 处理冲突的方法——**开放定址法**：所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：
  $$
  H_i=(H(key)+d_i)\%m
  $$
  i=0,1,2,...,k(k≦m-1)，**m表示散列表表长；d(i)为增量序列**；i可理解为“第i次发生冲突”。

  ①**线性探测法**——d(i)=0,1,2,...,m-1；即发生冲突时，每次往后探测相邻的下一个单元是否为空。线性探测法很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率。（产生原因：冲突后再探测一定是放在某个连续的位置）

  ②**平方探测法**——当d(i)=0²,1²,-1²,2²,-2²,...,k²,-k²时，称为平方探测法，又称二次探测法其中k≦m/2。比起线性探测法更不易产生“聚集（堆积）”现象。散列表长度m必须是一个可以表示成4j+3的素数，才能探测到所有位置。

  ③**伪随机序列法**——d(i)是一个伪随机序列，如d(i)=0,5,24,11,...。

  注意：采用“开放定址法”时，**删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除**。

- 处理冲突的方法——**再散列法（再哈希法）**：除了原始的散列函数H(key)之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：
  $$
  H_i=RH_i(Key)~~~~~~~~~~~~~~i=1,2,3,...,k
  $$
  