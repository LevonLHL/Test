# 第三章 栈和队列



## 栈

- **栈**是只允许在一端进行插入或者删除操作的**线性表**。

- **栈顶**：允许插入和删除的一端。

  **栈底**：不允许插入和删除的一端。

  **空栈**：空表。

- 特点：**先进后出**（LIFO）

- 基本操作：

  InitStack(&S):初始化栈。构造一个空栈S，分配内存空间。

  DestroyStack(&L):销毁栈。销毁并释放栈S所占用的内存空间。

  Push(&S,x):进栈。若栈S未满，则将x加入使之成为新栈顶。

  Pop(&S,&x):出栈。若栈S非空，则弹出栈顶元素，并用x返回。

  其他常用操作：

  StackEmpty(S):判断一个栈S是否为空。若S为空，则返回true，否则返回false。

- n个不同的元素进栈，出栈元素不同排列的个数为(1/(n+1))C(2n下标，n上标)。（卡特兰数）

- **顺序栈**：用顺序存储方式实现的栈。

  定义操作：静态数组存放栈中的元素；栈顶指针。

  （顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize * sizeof(ElemType)。）

  进栈操作：`S.data[++S.top]=x`。

  出栈操作：`x=S.data[S.top--]`。

  读栈操作：`x=S.data[S.top-1]`。

  栈满的条件：`top==MaxSize`。

  顺序栈的缺点：栈的大小不可变。

- **共享栈**：两个栈共享同一片空间。

  需要两个栈顶指针，分别从内存两端向内填数据。（`S.top0=-1；S.top1=MaxSize`）

  栈满条件：`top0 + 1 == top1`。

- **链栈**：用链式存储方式实现的栈。

  用法跟链表基本一致，只是进栈/出栈都只能在栈顶一端进行（链头作为栈顶）。



## 队列

- **队列**是只允许在一端进行插入，在另一端删除的**线性表**。

- **队头**：运行删除的一端。

  **队尾**：允许插入的一端。

  **空队列**：空表。

- 特点：**先进先出**（FIFO）

- 基本操作：

  InitQueue(&Q):初始化队列。构造一个空队列Q，分配内存空间。

  DestroyQueue(&Q):销毁队列。销毁并释放队列Q所占用的内存空间。

  EnQueue(&Q,x):入队。若队列Q未满，则将x加入使之成为新队尾。

  DeQueue(&Q,&x):出队。若队列Q非空，删除队头元素，并用x返回。

  GetHead(Q,&x):读队头元素，若队列Q非空，则将队头元素赋值给x。

  其他常用操作：

  QueueEmpty(Q):判断一个队列Q是否为空。若Q为空，则返回true，否则返回false。

- **队列的顺序实现**：

  定义操作：用静态数组存放队列元素，还应有队头指针（front）和队尾指针（rear）（指向队尾元素的后一个位置）。

  判空操作：`Q.rear==Q.front`。

  入队操作：`Q.rear=(Q.rear+1)%MaxSize` 可以将存储空间在逻辑上变成了“环状”。（**循环队列**）

  ​					队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front。（代价：牺牲一个存储单元。）

  出队操作：`Q.front=(Q.front+1)%MaxSize`  队头指针后移。

  查找操作：`x=Q.data[Q.front]`。

  **队列元素个数**：(rear+MaxSize-front)%MaxSize。

  队尾指针指向队尾元素：判空：`(Q.rear+1)%MaxSize==Q.front`。

  ​										  判满：1.牺牲一个存储单元。2.增加辅助变量（a.增加size变量记录队列长度。b.增加tag=0/1用于标记最近													  的一次操作是出队/入队。）。

- 链队列：**链式存储实现的队列**

  **带头节点**：初始化：`Q.front->next=NULL`。

  ​					判空：`Q.front==Q.rear`。

  ​					入队：

  ```c
LinkNode * s=(LinkNode *)malloc(sizeof(LinkNode));
  s->data=x;
s->next=NULL;
  Q.rear->next=s;		//新节点插入到rear之后
  Q.rear=s;			//修改表尾指针
  ```
  
  ​					出队：
  
  ```
  if(Q.front == NULL)
  	return false;				//空队
  LinkNode *p=Q.front->next;		
  x=p->data;						//用变量x返回队头元素
  Q.front->next=p->next;			//修改头节点的next指针
  if(Q.rear==p){					//此次是最后一个节点出队
  	Q.rear = Q.front;			//修改rear指针
  }
  free(p);						//释放节点空间
  return true;
  ```
  
  ​					队列满的条件：一般不会队满，除非内存空间不足。
  
  
  
  **不带头节点**：初始化：`Q.front=NULL;Q.rear=NULL`。
  
  ​					   判空：`Q.front==NULL`。
  
  ​					   入队：
  
  ```C
  LinkNode * s=(LinkNode *)malloc(sizeof(LinkNode));
  s->data=x;
  s->next=NULL;
  if(Q.front == NULL){	//在空队列中插入第一个元素
      Q.front = s;		//修改队头队尾指针
      Q.rear = s;
  }
  Q.rear->next=s;		
  Q.rear=s;			
  ```
  
  ​						出队：
  
  ```
  if(Q.front == NULL)
  	return false;			//空队
  LinkNode *p=Q.front;		//p指向此次出队的节点
  x=p->data;					//用变量x返回队头元素
  Q.front=p->next;			//修改front指针
  if(Q.rear==p){				//此次是最后一个节点出队
  	Q.front = NULL;			//front指向NULL
  	Q.rear = NULL;			//rear指向NULL
  }
  free(p);					//释放节点空间
  return true;
  ```
  
  ​						队列满的条件：（同上）



## 双端队列

- **双端队列**：只允许从两端插入、两端删除的线性表。
- **输入受限的双端队列**：只允许从一端插入、两端删除的线性表。
- **输出受限的双端队列**：只允许从两端插入、一端删除的线性表。
- 对输出序列合法性的判断：在栈中合法的输出序列，在双端队列中必定合法。



## 栈的应用

- 括号匹配：遇到左括号就入栈，遇到右括号就“消耗”一个左括号（出栈）。

  右括号单身：扫描到右括号且栈空。

  左括号单身：处理完所有括号后，栈非空。

- 表达式求值：

  ​	三种算术表达式（由操作数、运算符、界限符组成，界限符只在中缀表达式出现）：中缀表达式（运算符在两个操作数中间）、后缀表达式（运算符在两个操作数后面）、前缀表达式（运算符在两个操作数前面）。

  ​	**中缀转后缀的<u>手算</u>方法**：（运算顺序不唯一，因此对应的后缀表达式也不唯一。）

  1. 确定中缀表达式中各个运算符的运算顺序。
  2. 选择下一个运算符，按照【**左操作数 右操作数 运算符**】的方式组合成一个新的操作数。
  3. 如果还有运算符没被处理，就继续（2）。
  4. “左优先”原则：只要左边的运算符能先计算，就优先算左边的，以保证手算和机算结果相同。

  ​    **后缀表达式的<u>手算</u>方法**：从左往右扫描，没遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数，注意两个操作数的左右顺序。

  ​	**用栈实现后缀表达式的计算**：（若表达式合法，则最后栈中只会留下一个元素，就是最终结果。）

  1. 从**左往右**扫描下一个元素，直到处理完所有元素。
  2. 若扫描到操作数则压入栈，并回到（1）；否则执行（3）。
  3. 若扫描到运算符，则弹出两个栈顶元素，执行相应运算（注意：**先出栈的是右操作数**），运算结果压回栈顶，回到（1）。

  ​    **中缀转前缀的<u>手算</u>方法**：（运算顺序不唯一，因此对应的后缀表达式也不唯一。除非按“右优先”原则。）

  1. 确定中缀表达式中各个运算符的运算顺序。
  2. 选择下一个运算符，按照【**运算符 左操作数 右操作数**】的方式组合成一个新的操作数。
  3. 如果还有运算符没被处理，就继续（2）。
  4. “右优先”原则：只要右边的运算符能先计算，就优先算右边的，以保证手算和机算结果相同。

  ​	**用栈实现前缀表达式的计算**：（若表达式合法，则最后栈中只会留下一个元素，就是最终结果。除非按“左优先”原则。）

  1. 从**右往左**扫描下一个元素，直到处理完所有元素。
  2. 若扫描到操作数则压入栈，并回到（1）；否则执行（3）。
  3. 若扫描到运算符，则弹出两个栈顶元素，执行相应运算（注意：**先出栈的是左操作数**），运算结果压回栈顶，回到（1）。

  ​    **中缀表达式转后缀表达式的<u>机算</u>方法**：

  ​	初始化一个栈用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：

  1. 遇到**操作数**：直接加入后缀表达式。
  2. **遇到界限符**：遇到“（”直接入栈；遇到“）”则依次弹出栈内运算符并加入后缀表达式，直到弹出“（”为止。注意：“（”不加入后缀表达式。
  3. **遇到运算符**：依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“（”或栈空则停止。之后再把当前运算符入栈。

  ​    按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。

  ​	**用栈实现中缀表达式的机算**：

  1. 初始化两个栈，**操作数栈**和**运算符栈**。
  2. 若扫描到操作数，则压入操作数栈。
  3. 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，**每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈**。）

- 递归（由递归体，递归出口组成）应用：

  函数调用的特点：最后被调用的函数最先执行结束（LIFO）。

  函数调用时，需要用一个栈存储：调用返回值；实参；局部变量。

  适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题。

  递归调用时，函数调用栈可称为“递归工作栈”。每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息。

  缺点：太多层递归可能会导致栈溢出；可能包含很多重复机算。递归算法的空间复杂度也会更高（效率低）。



## 队列的应用

- 树的层次遍历
- 图的广度优先遍历
- 在操作系统中的应用，先来先服务（FCFS）
- 打印机，缓冲区用队列组织打印数据，可缓解主机与打印机速度不匹配的问题。



## 特殊矩阵的压缩存储

- 二维数组的存储结构：分行优先存储和列优先存储。

  M行N列的二维数组`b[M][N]`中，若按行优先存储，则`b[i][j]`的存储地址=LOC + (i * N + j) * sizeof(ElemType)

  ​														 若按列优先存储，则`b[i][j]`的存储地址=LOC + (j * M + i) * sizeof(ElemType)

  LOC是起始地址。

- 注意：描述矩阵元素时，行、列号通常从1开始；而描述数组时通常下标从0开始。

- **对称矩阵的压缩存储**：①只存储主对角线+下三角区。按行优先原则将各元素存入一维数组中。

  ​										②按列优先原则，a(i,j)=a(j,i)，同上。

- **三角矩阵的压缩存储**：按行优先原则将上三角或下三角区元素存入一维数组中。并在最后一个位置存储常量C。

- **三对角矩阵（带状矩阵）的压缩存储**：当|i-j|>1时，有a(i,j)=0是带状矩阵。

  按行优先（或列优先）原则，只存储带状部分。

- **稀疏矩阵的压缩存储**：非零元素远远少于矩阵元素的个数。

  顺序存储——三元组<行,列,值>;

  l链式存储——十字链表法